<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Price Dashboard</title>
    <!-- Plotly.js for charts -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Fetch API polyfill for older browsers -->
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --accent-color: #f39c12;
            --danger-color: #e74c3c;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #333;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        
        header {
            background-color: var(--dark-color);
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: var(--box-shadow);
            width: 100%;
            box-sizing: border-box;
        }
        
        h1 {
            margin: 0;
            font-size: 2rem;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 15px;
            margin-top: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .sidebar {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
            width: 100%;
            box-sizing: border-box;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .metrics-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .metric-card {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
            text-align: center;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 100%;
            box-sizing: border-box;
        }
        
        .metric-title {
            font-size: 1rem;
            color: #666;
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 5px;
            word-break: break-word;
        }
        
        .metric-change {
            font-size: 1rem;
        }
        
        .positive-change {
            color: var(--secondary-color);
        }
        
        .negative-change {
            color: var(--danger-color);
        }
        
        .chart-container {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 10px 5px 5px 5px;
            box-shadow: var(--box-shadow);
            margin-bottom: 30px;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .info-box {
            background-color: #d1ecf1;
            color: #0c5460;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .warning-box {
            background-color: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .error-box {
            background-color: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            width: 100%;
        }
        
        .loading::after {
            content: "";
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Fix for Plotly charts to prevent expanding */
        .js-plotly-plot, .plot-container {
            width: 100% !important;
        }
        
        .main-svg {
            width: 100% !important;
        }
    </style>
</head>
<body>
    <header>
        <h1>Bitcoin Price Dashboard</h1>
    </header>
    
    <div class="container">
        <div class="dashboard">
            <div class="sidebar">
                <h2>Dashboard Settings</h2>
                <div id="time-window-info" class="info-box">
                    Target chart window: 30 minutes
                </div>
                <div id="cold-start-info" class="info-box">
                    Cold start mode is enabled. For new systems with less than 30 minutes of data, 
                    charts will automatically adjust to show all available data.
                </div>
                <div id="status-box" class="info-box">
                    Normal mode: Showing 30 minutes of data
                </div>
                <h3>Dashboard Info</h3>
                <p><strong>Last Update (UTC):</strong> <span id="last-update">Loading...</span></p>
            </div>
            
            <div class="main-content">
                <div class="metrics-container">
                    <div class="metric-card">
                        <div class="metric-title">Current Price</div>
                        <div class="metric-value" id="current-price">Loading...</div>
                        <div class="metric-change" id="price-change">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Predicted Price</div>
                        <div class="metric-value" id="predicted-price">Loading...</div>
                        <div class="metric-change" id="prediction-accuracy">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Mean Absolute Error</div>
                        <div class="metric-value" id="mae-value">Loading...</div>
                        <div class="metric-change" id="mae-change">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Confidence Level</div>
                        <div class="metric-value" id="confidence-level">Loading...</div>
                        <div class="metric-change" id="confidence-change">-</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="price-chart" style="height: 600px;"></div>
                </div>
                
                <div class="chart-container">
                    <div id="prediction-chart" style="height: 500px;"></div>
                </div>
                
                <div class="chart-container">
                    <div id="mae-chart" style="height: 500px;"></div>
                </div>
                
                <div class="chart-container">
                    <div id="error-distribution-chart" style="height: 500px;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Configuration
        const config = {
            refreshInterval: 1000, // 1 second - matches Streamlit dashboard
            timeWindowMinutes: 30,
            apiBaseUrl: '/api',
            coldStart: {
                enabled: true,
                minDataPoints: 10
            },
            colors: {
                actualUp: '#2ecc71',    // Green for price increase
                actualDown: '#e74c3c',  // Red for price decrease
                predicted: '#f39c12',   // Orange for predictions
                actual: '#3498db',      // Blue for actual prices
                confidence: 'rgba(243, 156, 18, 0.2)'  // Semi-transparent orange for confidence intervals
            }
        };
        
        // API endpoints
        const endpoints = {
            priceData: `${config.apiBaseUrl}/price-data`,
            predictionData: `${config.apiBaseUrl}/prediction-data`,
            metricsData: `${config.apiBaseUrl}/metrics-data`
        };
        
        // Dashboard state
        let state = {
            priceData: [],
            predictionData: [],
            metricsData: [],
            isColdStart: false,
            coldStartMinutes: 0,
            lastUpdate: null,
            chartsInitialized: false
        };
        
        // Initialize charts
        let priceChart = null;
        let predictionChart = null;
        let maeChart = null;
        let errorDistributionChart = null;
        
        // Format price as USD
        function formatPrice(price) {
            return new Intl.NumberFormat('en-US', { 
                style: 'currency', 
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(price);
        }
        
        // Format price change (can be positive or negative)
        function formatPriceChange(change) {
            const formatted = formatPrice(Math.abs(change));
            return change >= 0 ? `+${formatted}` : `-${formatted}`;
        }
        
        // Format timestamp for display (with UTC indicator)
        function formatTimestamp(dateString) {
            const date = new Date(dateString);
            return dateString; // Keep the ISO format without UTC indicator
        }
        
        // Format timestamp for chart display (simplified)
        function formatChartTimestamp(dateString) {
            const date = new Date(dateString);
            return date.getHours().toString().padStart(2, '0') + ':' + 
                   date.getMinutes().toString().padStart(2, '0');
        }
        
        // Filter data to last N minutes
        function filterLastNMinutes(data, minutes) {
            if (!data || data.length === 0) return [];
            
            const cutoffTime = new Date();
            cutoffTime.setMinutes(cutoffTime.getMinutes() - minutes);
            
            return data.filter(item => new Date(item.timestamp) >= cutoffTime);
        }
        
        // Create price candlestick chart
        function createPriceChart(data) {
            if (!data || data.length === 0) {
                document.getElementById('price-chart').innerHTML = 
                    '<div class="info-box">No price data available</div>';
                return;
            }
            
            try {
                const layout = {
                    title: 'Bitcoin Price (Candlestick Chart)',
                    yaxis: {
                        title: 'Price (USD)',
                        tickformat: '$,.0f',
                        autorange: true
                    },
                    xaxis: {
                        title: 'Time (UTC)',
                        tickformat: '%H:%M',
                        tickangle: -45,
                        nticks: 8
                    },
                    template: 'plotly_white',
                    showlegend: false,
                    xaxis_rangeslider_visible: false,
                    margin: {
                        l: 60,
                        r: 40,
                        t: 50,
                        b: 80
                    },
                    height: 600,
                    autosize: true,
                    width: null  // Let Plotly use container width
                };
                
                // Make sure we have valid data
                const validData = data.filter(d => 
                    d && d.timestamp && d.open !== undefined && 
                    d.high !== undefined && d.low !== undefined && 
                    d.close !== undefined
                );
                
                if (validData.length === 0) {
                    document.getElementById('price-chart').innerHTML = 
                        '<div class="info-box">No valid price data available</div>';
                    return;
                }
                
                // Set fixed time window
                const maxTime = new Date(Math.max(...validData.map(d => new Date(d.timestamp))));
                const minTime = new Date(maxTime);
                minTime.setMinutes(minTime.getMinutes() - config.timeWindowMinutes);
                layout.xaxis.range = [minTime, maxTime];
                
                const trace = {
                    x: validData.map(d => d.timestamp),
                    open: validData.map(d => d.open),
                    high: validData.map(d => d.high),
                    low: validData.map(d => d.low),
                    close: validData.map(d => d.close),
                    type: 'candlestick',
                    name: 'Bitcoin Price',
                    increasing: { line: { color: config.colors.actualUp } },
                    decreasing: { line: { color: config.colors.actualDown } }
                };
                
                Plotly.newPlot('price-chart', [trace], layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } catch (error) {
                console.error('Error creating price chart:', error);
                document.getElementById('price-chart').innerHTML = 
                    '<div class="error-box">Error creating price chart: ' + error.message + '</div>';
            }
        }
        
        // Create prediction chart with confidence interval
        function createPredictionChart(priceData, predictionData) {
            if (!priceData || priceData.length === 0 || !predictionData || predictionData.length === 0) {
                document.getElementById('prediction-chart').innerHTML = 
                    '<div class="info-box">No prediction data available</div>';
                return;
            }
            
            try {
                // Make sure we have valid data
                const validPriceData = priceData.filter(d => 
                    d && d.timestamp && d.close !== undefined
                );
                
                const validPredictionData = predictionData.filter(d => 
                    d && d.timestamp && d.pred_price !== undefined &&
                    d.pred_lower !== undefined && d.pred_upper !== undefined
                );
                
                if (validPriceData.length === 0 || validPredictionData.length === 0) {
                    document.getElementById('prediction-chart').innerHTML = 
                        '<div class="info-box">No valid prediction data available</div>';
                    return;
                }
                
                const traces = [];
                const layout = {
                    title: 'Predicted Price with Confidence Interval vs Actual',
                    yaxis: {
                        title: 'Price (USD)',
                        tickformat: '$,.0f',
                        autorange: true
                    },
                    xaxis: {
                        title: 'Time (UTC)',
                        tickformat: '%H:%M',
                        tickangle: -45,
                        nticks: 8
                    },
                    template: 'plotly_white',
                    showlegend: true,
                    margin: {
                        l: 60,
                        r: 40,
                        t: 50,
                        b: 80
                    },
                    height: 500,
                    autosize: true,
                    width: null  // Let Plotly use container width
                };
                
                // Set fixed time window using price data
                const maxTime = new Date(Math.max(...validPriceData.map(d => new Date(d.timestamp))));
                const minTime = new Date(maxTime);
                minTime.setMinutes(minTime.getMinutes() - config.timeWindowMinutes);
                layout.xaxis.range = [minTime, maxTime];
                
                // Add actual price line
                traces.push({
                    x: validPriceData.map(d => d.timestamp),
                    y: validPriceData.map(d => d.close),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Actual Price',
                    line: { color: config.colors.actual, width: 2 }
                });
                
                // Add prediction line
                traces.push({
                    x: validPredictionData.map(d => d.timestamp),
                    y: validPredictionData.map(d => d.pred_price),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Predicted Price',
                    line: { color: config.colors.predicted, width: 2 }
                });
                
                // Add upper bound
                traces.push({
                    x: validPredictionData.map(d => d.timestamp),
                    y: validPredictionData.map(d => d.pred_upper),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Upper Bound',
                    line: { color: config.colors.predicted, width: 1, dash: 'dash' }
                });
                
                // Add lower bound with fill
                traces.push({
                    x: validPredictionData.map(d => d.timestamp),
                    y: validPredictionData.map(d => d.pred_lower),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Lower Bound',
                    line: { color: config.colors.predicted, width: 1, dash: 'dash' },
                    fill: 'tonexty',
                    fillcolor: config.colors.confidence
                });
                
                Plotly.newPlot('prediction-chart', traces, layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } catch (error) {
                console.error('Error creating prediction chart:', error);
                document.getElementById('prediction-chart').innerHTML = 
                    '<div class="error-box">Error creating prediction chart: ' + error.message + '</div>';
            }
        }
        
        // Update error distribution chart
        function updateErrorDistributionChart(metricsData) {
            try {
                // For the error distribution chart, we recreate it completely
                // using all available data points (not just the time window)
                createErrorDistributionChart(metricsData);
            } catch (error) {
                console.error('Error updating error distribution chart:', error);
                document.getElementById('error-distribution-chart').innerHTML = 
                    '<div class="error-box">Error updating error distribution chart: ' + error.message + '</div>';
            }
        }
        
        // Create error distribution chart
        function createErrorDistributionChart(metricsData) {
            if (!metricsData || metricsData.length === 0 || !metricsData[0]) {
                document.getElementById('error-distribution-chart').innerHTML = 
                    '<div class="info-box">No error distribution data available</div>';
                return;
            }
            
            try {
                // Extract error values - use ALL available data points for the distribution
                // Don't filter by time window for the error distribution to ensure we have enough data points
                const errors = metricsData
                    .filter(d => d && d.hasOwnProperty('actual_error'))
                    .map(d => d.actual_error || 0)
                    .filter(e => !isNaN(e));
                
                if (errors.length === 0) {
                    document.getElementById('error-distribution-chart').innerHTML = 
                        '<div class="info-box">No valid error data available</div>';
                    return;
                }
                
                // Calculate statistics
                const mean = errors.reduce((sum, val) => sum + val, 0) / errors.length;
                const median = [...errors].sort((a, b) => a - b)[Math.floor(errors.length / 2)];
                const roundedMean = Math.round(mean * 100) / 100;
                const roundedMedian = Math.round(median * 100) / 100;
                
                // Calculate standard deviation
                const variance = errors.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / errors.length;
                const std = Math.sqrt(variance);
                
                // Determine appropriate number of bins based on data size
                const binCount = Math.min(20, Math.max(5, Math.ceil(Math.sqrt(errors.length))));
                
                // Create histogram trace with consistent binning
                const histTrace = {
                    x: errors,
                    type: 'histogram',
                    name: 'Error Distribution',
                    marker: {
                        color: 'rgba(173, 216, 230, 0.7)',  // lightblue with transparency
                        line: {
                            color: 'rgba(173, 216, 230, 1)',
                            width: 1
                        }
                    },
                    opacity: 0.8,
                    nbinsx: binCount,
                    autobinx: false  // Disable automatic binning
                };
                
                // Calculate normal distribution overlay
                const xValues = [];
                const yValues = [];
                const min = Math.min(...errors);
                const max = Math.max(...errors);
                const range = max - min || 1; // Prevent division by zero
                const step = range / 100;
                
                // Generate normal distribution curve with more points for smoothness
                for (let x = min - range * 0.3; x <= max + range * 0.3; x += step) {
                    xValues.push(x);
                    // Normal distribution PDF
                    const y = (1 / (std * Math.sqrt(2 * Math.PI))) * 
                            Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(std, 2)));
                    yValues.push(y);
                }
                
                // Simple approach to estimate bin heights
                let maxBinHeight = 10; // Default value
                try {
                    // Simple histogram calculation
                    const binSize = range / binCount;
                    const bins = Array(binCount).fill(0);
                    
                    errors.forEach(error => {
                        if (binSize > 0) {
                            const binIndex = Math.min(Math.floor((error - min) / binSize), binCount - 1);
                            if (binIndex >= 0 && binIndex < binCount) {
                                bins[binIndex]++;
                            }
                        }
                    });
                    
                    maxBinHeight = Math.max(...bins, 1); // Ensure it's at least 1
                } catch (e) {
                    console.error('Error calculating histogram bins:', e);
                    // Use a reasonable default based on data size
                    maxBinHeight = Math.ceil(errors.length / binCount);
                }
                
                // Find the maximum value in the normal PDF
                const maxPdfValue = Math.max(...yValues, 0.001); // Ensure it's not zero
                
                // Scale factor to match histogram height
                const scaleFactor = maxBinHeight / maxPdfValue;
                
                // Apply scaling
                const scaledYValues = yValues.map(y => y * scaleFactor);
                
                const normalCurve = {
                    x: xValues,
                    y: scaledYValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Normal Distribution',
                    line: {
                        color: 'rgb(0, 0, 139)',  // darkblue
                        width: 2
                    }
                };
                
                // Add vertical lines for mean, median, and perfect prediction
                const perfectLine = {
                    x: [0, 0],
                    y: [0, maxBinHeight * 1.1],  // Slightly higher than the tallest bin
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Perfect',
                    line: {
                        color: 'black',
                        width: 2
                    },
                    hoverinfo: 'none'
                };
                
                const medianLine = {
                    x: [median, median],
                    y: [0, maxBinHeight * 1.1],
                    type: 'scatter',
                    mode: 'lines',
                    name: `Median: ${roundedMedian}`,
                    line: {
                        color: 'green',
                        width: 2,
                        dash: 'dash'
                    },
                    hoverinfo: 'none'
                };
                
                const meanLine = {
                    x: [mean, mean],
                    y: [0, maxBinHeight * 1.1],
                    type: 'scatter',
                    mode: 'lines',
                    name: `Mean: ${roundedMean}`,
                    line: {
                        color: 'red',
                        width: 2,
                        dash: 'dash'
                    },
                    hoverinfo: 'none'
                };
                
                const layout = {
                    title: `Prediction Error Distribution (${errors.length} data points)<br>Median: ${roundedMedian} Mean: ${roundedMean}`,
                    xaxis: {
                        title: 'Error (USD)',
                        tickformat: '$,.2f',  // Show 2 decimal places for better precision
                        autorange: true,
                        zeroline: true,
                        zerolinecolor: 'black',
                        zerolinewidth: 2
                    },
                    yaxis: {
                        title: 'Frequency',
                        autorange: true
                    },
                    template: 'plotly_white',
                    bargap: 0.05,
                    showlegend: true,
                    margin: {
                        l: 60,
                        r: 40,
                        t: 60,
                        b: 60
                    },
                    height: 500,
                    autosize: true,
                    width: null  // Let Plotly use container width
                };
                
                Plotly.newPlot('error-distribution-chart', [histTrace, normalCurve, perfectLine, medianLine, meanLine], layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } catch (error) {
                console.error('Error creating error distribution chart:', error);
                document.getElementById('error-distribution-chart').innerHTML = 
                    '<div class="error-box">Error creating chart: ' + error.message + '</div>';
            }
        }
        
        // Update metrics display
        function updateMetricsDisplay() {
            try {
                // Update last update time
                if (state.lastUpdate) {
                    document.getElementById('last-update').textContent = 
                        state.lastUpdate.toISOString().replace(/\.\d+Z$/, '');
                }
                
                // Update cold start info
                const coldStartInfoElement = document.getElementById('cold-start-info');
                if (state.isColdStart) {
                    coldStartInfoElement.innerHTML = 
                        `<div class="warning-box">Cold Start Mode: ${Math.round(state.coldStartMinutes)} minutes of data</div>`;
                } else {
                    coldStartInfoElement.innerHTML = '';
                }
                
                // Update metrics if we have data
                if (state.priceData && state.priceData.length > 0) {
                    const latestPrice = state.priceData[state.priceData.length - 1];
                    
                    // Update latest price
                    document.getElementById('current-price').textContent = formatPrice(latestPrice.close);
                    
                    // Update price change
                    if (state.priceData.length > 1) {
                        const previousPrice = state.priceData[state.priceData.length - 2];
                        const priceChange = latestPrice.close - previousPrice.close;
                        
                        const priceChangeElement = document.getElementById('price-change');
                        priceChangeElement.textContent = formatPriceChange(priceChange);
                        priceChangeElement.className = 'metric-change ' + 
                            (priceChange >= 0 ? 'positive-change' : 'negative-change');
                    }
                }
                
                // Update prediction metrics
                if (state.predictionData && state.predictionData.length > 0 && 
                    state.priceData && state.priceData.length > 0) {
                    
                    const latestPrediction = state.predictionData[state.predictionData.length - 1];
                    const latestPrice = state.priceData[state.priceData.length - 1];
                    
                    // Update latest prediction
                    if (latestPrediction.pred_price !== undefined) {
                        document.getElementById('predicted-price').textContent = formatPrice(latestPrediction.pred_price);
                        
                        // Update prediction change
                        if (latestPrice.close !== undefined) {
                            const predChange = latestPrediction.pred_price - latestPrice.close;
                            
                            const predChangeElement = document.getElementById('prediction-accuracy');
                            predChangeElement.textContent = formatPriceChange(predChange);
                            predChangeElement.className = 'metric-change ' + 
                                (Math.abs(predChange) < 100 ? 'positive-change' : 'negative-change');
                        }
                    }
                    
                    // Update confidence level
                    if (latestPrediction.pred_upper !== undefined && 
                        latestPrediction.pred_lower !== undefined) {
                        
                        const range = latestPrediction.pred_upper - latestPrediction.pred_lower;
                        const confidence = 100 - (range / latestPrediction.pred_price * 100);
                        
                        document.getElementById('confidence-level').textContent = 
                            confidence.toFixed(1) + '%';
                            
                        // Determine if confidence is good
                        const confidenceChangeElement = document.getElementById('confidence-change');
                        confidenceChangeElement.textContent = 
                            confidence > 90 ? 'High' : confidence > 80 ? 'Medium' : 'Low';
                        confidenceChangeElement.className = 'metric-change ' + 
                            (confidence > 90 ? 'positive-change' : 
                             confidence > 80 ? '' : 'negative-change');
                    }
                }
                
                // Update MAE if we have metrics data
                if (state.metricsData && state.metricsData.length > 0) {
                    const latestMetrics = state.metricsData[state.metricsData.length - 1];
                    
                    if (latestMetrics.mae !== undefined) {
                        document.getElementById('mae-value').textContent = formatPrice(latestMetrics.mae);
                        
                        // Determine if MAE is good
                        const maeChangeElement = document.getElementById('mae-change');
                        const maePercent = (latestMetrics.mae / latestMetrics.price) * 100;
                        
                        // Debug logging to understand the calculation
                        console.log(`MAE Rating Calculation: MAE=${latestMetrics.mae}, Latest Price=${latestMetrics.price}, MAE Percent=${maePercent}%`);
                        
                        // Adjusted thresholds for Bitcoin's high price
                        // For high-value assets like Bitcoin, even small percentage errors can be significant
                        const rating = 
                            maePercent < 0.001 ? 'Excellent' : 
                            maePercent < 0.01 ? 'Good' : 
                            maePercent < 0.1 ? 'Fair' : 'Poor';
                        
                        console.log(`MAE Rating: ${rating} (${maePercent}%)`);
                        
                        maeChangeElement.textContent = rating;
                        
                        maeChangeElement.className = 'metric-change ' + 
                            (maePercent < 0.01 ? 'positive-change' : 
                             maePercent < 0.1 ? '' : 'negative-change');
                    }
                }
            } catch (error) {
                console.error('Error updating metrics display:', error);
            }
        }
        
        // Fetch data from API
        async function fetchData() {
            let hasNewData = false;
            
            try {
                // Fetch price data
                try {
                    const priceResponse = await fetch(endpoints.priceData);
                    if (priceResponse.ok) {
                        const priceData = await priceResponse.json();
                        if (Array.isArray(priceData) && priceData.length > 0) {
                            state.priceData = priceData;
                            hasNewData = true;
                        } else {
                            console.warn('Received empty or invalid price data');
                        }
                    } else {
                        console.error('Failed to fetch price data:', priceResponse.status);
                    }
                } catch (error) {
                    console.error('Error fetching price data:', error);
                }
                
                // Fetch prediction data
                try {
                    const predictionResponse = await fetch(endpoints.predictionData);
                    if (predictionResponse.ok) {
                        const predictionData = await predictionResponse.json();
                        if (Array.isArray(predictionData) && predictionData.length > 0) {
                            state.predictionData = predictionData;
                            hasNewData = true;
                        } else {
                            console.warn('Received empty or invalid prediction data');
                        }
                    } else {
                        console.error('Failed to fetch prediction data:', predictionResponse.status);
                    }
                } catch (error) {
                    console.error('Error fetching prediction data:', error);
                }
                
                // Fetch metrics data
                try {
                    const metricsResponse = await fetch(endpoints.metricsData);
                    if (metricsResponse.ok) {
                        const metricsData = await metricsResponse.json();
                        if (Array.isArray(metricsData) && metricsData.length > 0) {
                            // Check if we have actual_error field in the data
                            const hasActualError = metricsData.some(d => d && d.hasOwnProperty('actual_error'));
                            if (hasActualError) {
                                state.metricsData = metricsData;
                                hasNewData = true;
                            } else {
                                console.warn('Metrics data missing actual_error field');
                            }
                        } else {
                            console.warn('Received empty or invalid metrics data');
                        }
                    } else {
                        console.error('Failed to fetch metrics data:', metricsResponse.status);
                    }
                } catch (error) {
                    console.error('Error fetching metrics data:', error);
                }
                
                // Only update charts if we have new data
                if (hasNewData) {
                    if (state.chartsInitialized) {
                        updateCharts();
                        updateMetricsDisplay(); // Ensure metrics are updated
                    } else {
                        initializeCharts();
                        state.chartsInitialized = true;
                    }
                }
                
                state.lastUpdate = new Date();
            } catch (error) {
                console.error('Error in fetchData:', error);
                
                // Show error message
                const errorBox = document.createElement('div');
                errorBox.className = 'error-box';
                errorBox.textContent = `Error updating dashboard: ${error.message}`;
                
                // Remove previous error messages
                document.querySelectorAll('.error-box').forEach(box => {
                    if (box.parentNode === document.querySelector('.main-content')) {
                        box.remove();
                    }
                });
                
                // Add new error message at the top of main content
                const mainContent = document.querySelector('.main-content');
                if (mainContent) {
                    mainContent.insertBefore(errorBox, mainContent.firstChild);
                    
                    // Auto-remove error after 10 seconds
                    setTimeout(() => {
                        if (errorBox.parentNode === mainContent) {
                            errorBox.remove();
                        }
                    }, 10000);
                }
            }
            
            // Schedule the next data fetch regardless of success/failure
            setTimeout(fetchData, config.refreshInterval);
        }
        
        // Initialize charts
        function initializeCharts() {
            try {
                // Price chart
                if (state.priceData && state.priceData.length > 0) {
                    try {
                        createPriceChart(state.priceData);
                    } catch (error) {
                        console.error('Error creating price chart:', error);
                        document.getElementById('price-chart').innerHTML = 
                            '<div class="info-box">Error creating price chart: ' + error.message + '</div>';
                    }
                } else {
                    document.getElementById('price-chart').innerHTML = 
                        '<div class="info-box">Waiting for price data...</div>';
                }
                
                // Prediction chart
                if (state.priceData && state.priceData.length > 0 && 
                    state.predictionData && state.predictionData.length > 0) {
                    try {
                        createPredictionChart(state.priceData, state.predictionData);
                    } catch (error) {
                        console.error('Error creating prediction chart:', error);
                        document.getElementById('prediction-chart').innerHTML = 
                            '<div class="info-box">Error creating prediction chart: ' + error.message + '</div>';
                    }
                } else {
                    document.getElementById('prediction-chart').innerHTML = 
                        '<div class="info-box">Waiting for prediction data...</div>';
                }
                
                // MAE chart
                if (state.metricsData && state.metricsData.length > 0) {
                    try {
                        createMaeChart(state.metricsData);
                    } catch (error) {
                        console.error('Error creating MAE chart:', error);
                        document.getElementById('mae-chart').innerHTML = 
                            '<div class="info-box">Error creating MAE chart: ' + error.message + '</div>';
                    }
                } else {
                    document.getElementById('mae-chart').innerHTML = 
                        '<div class="info-box">Waiting for metrics data...</div>';
                }
                
                // Error distribution chart - always use all available data
                if (state.metricsData && state.metricsData.length > 0) {
                    try {
                        createErrorDistributionChart(state.metricsData);
                    } catch (error) {
                        console.error('Error creating error distribution chart:', error);
                        document.getElementById('error-distribution-chart').innerHTML = 
                            '<div class="info-box">Error creating error distribution chart: ' + error.message + '</div>';
                    }
                } else {
                    document.getElementById('error-distribution-chart').innerHTML = 
                        '<div class="info-box">Waiting for error distribution data...</div>';
                }
            } catch (error) {
                console.error('Error initializing charts:', error);
            }
        }
        
        // Update charts with new data
        function updateCharts() {
            // Update price chart
            if (state.priceData && state.priceData.length > 0) {
                try {
                    updatePriceChart(state.priceData);
                } catch (error) {
                    console.error('Error updating price chart:', error);
                }
            }
            
            // Update prediction chart
            if (state.priceData && state.priceData.length > 0 && 
                state.predictionData && state.predictionData.length > 0) {
                try {
                    updatePredictionChart(state.priceData, state.predictionData);
                } catch (error) {
                    console.error('Error updating prediction chart:', error);
                }
            }
            
            // Update MAE chart
            if (state.metricsData && state.metricsData.length > 0) {
                try {
                    updateMaeChart(state.metricsData);
                } catch (error) {
                    console.error('Error updating MAE chart:', error);
                }
            }
            
            // Update error distribution chart - always use all available data
            if (state.metricsData && state.metricsData.length > 0) {
                try {
                    updateErrorDistributionChart(state.metricsData);
                } catch (error) {
                    console.error('Error updating error distribution chart:', error);
                }
            }
        }
        
        // Update price chart with new data
        function updatePriceChart(data) {
            if (!data || data.length === 0) return;
            
            try {
                // Filter data to the last 30 minutes for a fixed window
                const maxTime = new Date(Math.max(...data.map(d => new Date(d.timestamp || 0))));
                const minTime = new Date(maxTime);
                minTime.setMinutes(minTime.getMinutes() - config.timeWindowMinutes);
                
                // Filter data to only include points within the time window
                const filteredData = data.filter(d => d.timestamp && new Date(d.timestamp) >= minTime);
                
                if (filteredData.length === 0) return;
                
                // Update the chart with the filtered data
                Plotly.update('price-chart', {
                    x: [filteredData.map(d => d.timestamp)],
                    open: [filteredData.map(d => d.open)],
                    high: [filteredData.map(d => d.high)],
                    low: [filteredData.map(d => d.low)],
                    close: [filteredData.map(d => d.close)]
                }, {
                    xaxis: {
                        range: [minTime, maxTime]
                    }
                });
            } catch (error) {
                console.error('Error updating price chart:', error);
            }
        }
        
        // Update prediction chart with new data
        function updatePredictionChart(priceData, predictionData) {
            if (!priceData || priceData.length === 0 || !predictionData || predictionData.length === 0) return;
            
            try {
                // Filter data to the last 30 minutes for a fixed window
                const maxTime = new Date(Math.max(...priceData.map(d => new Date(d.timestamp || 0))));
                const minTime = new Date(maxTime);
                minTime.setMinutes(minTime.getMinutes() - config.timeWindowMinutes);
                
                // Filter data to only include points within the time window
                const filteredPriceData = priceData.filter(d => d.timestamp && new Date(d.timestamp) >= minTime);
                const filteredPredictionData = predictionData.filter(d => d.timestamp && new Date(d.timestamp) >= minTime);
                
                if (filteredPriceData.length === 0 || filteredPredictionData.length === 0) return;
                
                // Update data for each trace
                const updateData = {
                    x: [
                        filteredPriceData.map(d => d.timestamp), // Actual price
                        filteredPredictionData.map(d => d.timestamp), // Predicted price
                        filteredPredictionData.map(d => d.timestamp), // Upper bound
                        filteredPredictionData.map(d => d.timestamp)  // Lower bound
                    ],
                    y: [
                        filteredPriceData.map(d => d.close),
                        filteredPredictionData.map(d => d.pred_price),
                        filteredPredictionData.map(d => d.pred_upper),
                        filteredPredictionData.map(d => d.pred_lower)
                    ]
                };
                
                Plotly.update('prediction-chart', updateData, {
                    xaxis: {
                        range: [minTime, maxTime]
                    }
                });
            } catch (error) {
                console.error('Error updating prediction chart:', error);
            }
        }
        
        // Create MAE (Mean Absolute Error) chart
        function createMaeChart(metricsData) {
            if (!metricsData || metricsData.length === 0) {
                document.getElementById('mae-chart').innerHTML = 
                    '<div class="info-box">No prediction error metrics available</div>';
                return;
            }
            
            try {
                // Check for metadata record (first record with is_metadata flag)
                let metadataRecord = metricsData.find(d => d.is_metadata === true);
                
                // Filter data to the last 30 minutes for a fixed window
                const maxTime = new Date(Math.max(...metricsData.map(d => new Date(d.timestamp || 0))));
                const minTime = new Date(maxTime);
                minTime.setMinutes(minTime.getMinutes() - config.timeWindowMinutes);
                
                // Filter data to only include points within the time window
                const filteredMetricsData = metricsData
                    .filter(d => !d.is_metadata && d.timestamp && new Date(d.timestamp) >= minTime);
                
                let recentAvgError = 0;
                let recentMae = 0;
                
                if (filteredMetricsData.length > 0) {
                    // Calculate metrics from the filtered data
                    const actualErrors = filteredMetricsData
                        .map(d => d.actual_error || 0)
                        .filter(e => !isNaN(e));
                    
                    if (actualErrors.length > 0) {
                        // Calculate average error (arithmetic mean of all errors, including sign)
                        recentAvgError = actualErrors.reduce((sum, val) => sum + val, 0) / actualErrors.length;
                        
                        // Calculate MAE (Mean Absolute Error - arithmetic mean of absolute errors)
                        recentMae = actualErrors.map(Math.abs).reduce((sum, val) => sum + val, 0) / actualErrors.length;
                        
                        // Round to 2 decimal places for display
                        recentAvgError = Math.round(recentAvgError * 100) / 100;
                        recentMae = Math.round(recentMae * 100) / 100;
                        
                        console.log(`Calculated from filtered data: Avg Error = ${recentAvgError}, MAE = ${recentMae}`);
                    } else if (metadataRecord) {
                        // Fall back to metadata if no filtered data points have actual_error
                        recentAvgError = metadataRecord.recent_avg_error || 0;
                        recentMae = metadataRecord.recent_mae || 0;
                        console.log(`Using metadata values: Avg Error = ${recentAvgError}, MAE = ${recentMae}`);
                    }
                } else if (metadataRecord) {
                    // Fall back to metadata if no filtered data
                    recentAvgError = metadataRecord.recent_avg_error || 0;
                    recentMae = metadataRecord.recent_mae || 0;
                    console.log(`Using metadata values: Avg Error = ${recentAvgError}, MAE = ${recentMae}`);
                }
                
                // Prepare data for chart
                const timestamps = filteredMetricsData.map(d => new Date(d.timestamp));
                const actualErrors = filteredMetricsData.map(d => d.actual_error || 0);
                const maes = filteredMetricsData.map(d => d.mae || 0);
                
                // Create chart
                const trace1 = {
                    x: timestamps,
                    y: actualErrors,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Actual Error',
                    line: {
                        color: '#3498db',
                        width: 2
                    }
                };
                
                // Add a horizontal line for the average error
                const avgErrorLine = {
                    x: [minTime, maxTime],
                    y: [recentAvgError, recentAvgError],
                    type: 'scatter',
                    mode: 'lines',
                    name: `Avg Error: ${recentAvgError}`,
                    line: {
                        color: 'blue',
                        width: 1,
                        dash: 'dash'
                    }
                };
                
                // Add MAE as a horizontal line
                const maeLine = {
                    x: [minTime, maxTime],
                    y: [recentMae, recentMae],
                    type: 'scatter',
                    mode: 'lines',
                    name: `MAE: ${recentMae}`,
                    line: {
                        color: '#e74c3c',
                        width: 2,
                        dash: 'dot'
                    }
                };
                
                const layout = {
                    title: {
                        text: `Prediction Error Over Time<br><span style="font-size:0.8em">Avg Error: ${recentAvgError}, MAE: ${recentMae}</span>`,
                        font: {
                            size: 16
                        }
                    },
                    xaxis: {
                        title: 'Time',
                        type: 'date',
                        tickformat: '%H:%M:%S',
                        gridcolor: '#f5f5f5'
                    },
                    yaxis: {
                        title: 'Error',
                        gridcolor: '#f5f5f5'
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    margin: {
                        l: 50,
                        r: 20,
                        t: 60,
                        b: 80
                    },
                    plot_bgcolor: '#ffffff',
                    paper_bgcolor: '#ffffff',
                    hovermode: 'closest'
                };
                
                const plotConfig = {
                    responsive: true,
                    displayModeBar: false
                };
                
                Plotly.newPlot('mae-chart', [trace1, avgErrorLine, maeLine], layout, plotConfig);
                
                // Update metrics display
                document.getElementById('mae-value').textContent = formatPrice(recentMae);
                
                // Determine if MAE is good
                const maeChangeElement = document.getElementById('mae-change');
                const latestPrice = state.priceData && state.priceData.length > 0 ? 
                    state.priceData[state.priceData.length - 1].close : 0;
                
                if (latestPrice > 0) {
                    const maePercent = (recentMae / latestPrice) * 100;
                    
                    // Debug logging to understand the calculation
                    console.log(`MAE Rating Calculation: MAE=${recentMae}, Latest Price=${latestPrice}, MAE Percent=${maePercent}%`);
                    
                    // Adjusted thresholds for Bitcoin's high price
                    // For high-value assets like Bitcoin, even small percentage errors can be significant
                    const rating = 
                        maePercent < 0.001 ? 'Excellent' : 
                        maePercent < 0.01 ? 'Good' : 
                        maePercent < 0.1 ? 'Fair' : 'Poor';
                    
                    console.log(`MAE Rating: ${rating} (${maePercent}%)`);
                    
                    maeChangeElement.textContent = rating;
                    
                    maeChangeElement.className = 'metric-change ' + 
                        (maePercent < 0.01 ? 'positive-change' : 
                         maePercent < 0.1 ? '' : 'negative-change');
                }
                
            } catch (error) {
                console.error('Error creating MAE chart:', error);
                document.getElementById('mae-chart').innerHTML = 
                    '<div class="error-box">Error creating MAE chart: ' + error.message + '</div>';
            }
        }
        
        // Update MAE chart with new data
        function updateMaeChart(metricsData) {
            if (!metricsData || metricsData.length === 0) return;
            
            try {
                // For the MAE chart, we recreate it completely
                // since we need to recalculate metrics and update annotations
                createMaeChart(metricsData);
            } catch (error) {
                console.error('Error updating MAE chart:', error);
                document.getElementById('mae-chart').innerHTML = 
                    '<div class="error-box">Error updating MAE chart: ' + error.message + '</div>';
            }
        }
        
        // Initialize dashboard
        function initDashboard() {
            // Initial data fetch - this will start the continuous fetch cycle
            fetchData();
        }
        
        // Start the dashboard when the page is loaded
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html> 